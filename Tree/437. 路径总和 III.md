## [437. 路径总和 III](https://leetcode-cn.com/problems/path-sum-iii/)

题目描述：

> 给定一个二叉树，它的每个结点都存放着一个整数值。找出路径和等于给定数值的路径总数。
>
> 路径不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。
>
> 二叉树不超过1000个节点，且节点数值范围是 [-1000000,1000000] 的整数。

#### 思路1：双递归

外层递归遍历所有结点，内层遍历当前节点路径和等于给定数值并记录路径数

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def __init__(self, cnt=0):
        self.cnt = cnt
    def pathSum(self, root: TreeNode, targetSum: int) -> int:
        if not root:
            return 0
        
        self.cnt = 0
        
        def dfs(root, res):
            if not root:
                return
            if sum(res) == targetSum: 
                self.cnt += 1
            if root.left:
                dfs(root.left, res + [root.left.val])
            if root.right:
                dfs(root.right, res + [root.right.val])

        def path(root):
            if not root:
                return
            dfs(root, [root.val])
            path(root.left)
            path(root.right)
        
        path(root)
        
        return self.cnt
```

更简洁的写法

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def pathSum(self, root: TreeNode, targetSum: int) -> int:
        if not root:
            return 0
        
        def dfs(root, Sum):
            cnt = 0
            if not root:
                return 0
            if Sum == root.val: 
                cnt += 1

            cnt += dfs(root.left, Sum - root.val)
            cnt += dfs(root.right, Sum - root.val)
            return cnt
        return dfs(root, targetSum) + self.pathSum(root.left, targetSum) + self.pathSum(root.right, targetSum)
```



#### 思路2：前缀和问题

