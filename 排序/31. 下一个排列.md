## [31. 下一个排列]()

**题目描述**

实现获取 **下一个排列** 的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。

如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。

必须 原地 修改，只允许使用额外常数空间。

```python
输入：nums = [1,2,3]
输出：[1,3,2]
```



### 思路：

1. 要找到下一个排列，也就是找到下一个比当前排列字典序大的排列，也就是需要将**后面一个较大的值**和**前面一个较小的值**进行交换；

2. 但是需要是刚好下一个排列，也就是不多不少，只大一个字典序值。

   > 举个栗子：
   >
   > 146325
   >
   > 下一个排列应该是
   >
   > 1463**52**
   >
   > 也就是将**5**和**2**进行交换，那么这两个值是如何找到的呢？
   >
   > 字典序的值本身包含高位和地位，希望只大一点，应该从低位开始找，也就是逆序遍历，从右往左遍历
   >
   > 上面的序列如果改成
   >
   > 146352
   >
   > 那么下一个排列应该是
   >
   > 146**523**
   >
   > 也就是说我们需要找到第一个（从后往前遍历）升序对，只有当后面的比前面的值大，才有增大的可能，比如全部逆序的序列654321，没有升序对，没有可以交换的空间，直接逆序输出即可。
   >
   > 再来，找到第一个升序对（i，i+1）也就是样例中的（3， 5）之后，需要找一个数与之交换，应该是从 [i+1:end]里面找到比nums[i]大的最小值，如果3后面有456，那当然应该先拿4和它交换，但此时 i 后面的值都是降序的，所以同样逆序遍历，找到第一个比nums[i]大的值即可（这个值就是所有比他大的值里最小的值）
   >
   > 找到“最小值”和”最大值“，交换，之后要对[i+1:end]的值进行升序排列（此时是降序排列），因为升序排列永远是最小的。
   >
   > 比如 xxxxx17654, nums[i] =1, nums[k] = 4，交换1和4之后是 xxxxx47651，对4之后的数字逆序排列得到 xxxxx41567，这个结果即为最小的排列。

   - 第一步：从后往前遍历，找到第一个升序对 (i:i+1)，而且 [i+1:end]都是降序排列；
   - 第二步：从后往前遍历，找到第一个比nums[i]大的值nums[k]；
   - 第三步：逆序nums[i+1:end]（注意题目要求**原地**修改，用切片逆序会使用额外的地址空间，所以对半分，交换值，实现降序列表转化为升序列表。
   - 第四步：如果原序列降序，用上述方法逆序。



```python
class Solution:
    def nextPermutation(self, nums: List[int]) -> None:
        """
        Do not return anything, modify nums in-place instead.
        """
        n = len(nums)
        for i in range(n-1, -1, -1):
            # 找到第一个升序对(i, i+1),[i+1:end]为降序
            if i < n-1 and nums[i] < nums[i+1]:
                # 从[i+1: end]找到一个最小的比nums[i]大的值:nums[k]
                for k in range(n-1, i, -1):
                    if nums[i] < nums[k]:
                        # 交换nums[i],nums[k]
                        nums[i], nums[k] = nums[k], nums[i]

                        # 逆序[i+1:end]的值，不能用切片，题目要求不适用额外空间
                        for j in range(i+1, (i+n)//2 + 1):
                            nums[j], nums[n-1] = nums[n-1], nums[j]
                            n -= 1
                        return nums
                    	# return nums[:i+1] + sorted(nums[i+1])

        for i in range(n//2):
            nums[i], nums[n-1] = nums[n-1], nums[i]
            n -= 1
        return nums
```

