## 十大排序方法总结

### 0. 总览

#### 0.0 分类

- Comparison Sorting（比较排序）
  - Bubble Sort（冒泡排序）
  - Selection Sort（选择排序）
  - Insertion Sort（插入排序）
  - Shell Sort（希尔排序）
  - Merge Sort（归并排序）
  - Quick Sort（快速排序）
- Bucket Sort（桶排序）
- Counting Sort（计数排序）
- Radix Sort（基数排序）
- Heap Sort（堆排序）

#### 0.1 排序涉及的问题：

1. 稳定：若a=b，排序后，ab位置不变；
2. 不稳定：若a=b，排序后，ab位置可能改变；
3. 内排序：所有排序操作都在内存中完成；
4. 外排序：由于数据太大，把数据放在磁盘里，排序通过磁盘和内存的数据传输才能进行；
5. 时间复杂度：分为平均、最坏、最好三种情况；
6. 空间复杂度。

#### 0.2 总结（cheat sheet）

|          | 平均时间复杂度 | 最好的情况 | 最坏的情况 | 空间复杂度 | 排序方式 | 稳定性 |
| :------: | :------------: | :--------: | :--------: | :--------: | :------: | :----: |
| 冒泡排序 |     O(n^2)     |    O(n)    |   O(n^2)   |    O(1)    | In Place |  稳定  |
| 选择排序 |     O(n^2)     |   O(n^2)   |   O(n^2)   |    O(1)    | In Place | 不稳定 |
| 插入排序 |     O(n^2)     |    O(n)    |   O(n^2)   |    O(1)    | In Place |  稳定  |
| 希尔排序 |                |            |            |            |          |        |
| 归并排序 |                |            |            |            |          |        |
| 快速排序 |                |            |            |            |          |        |
|  堆排序  |                |            |            |            |          |        |
| 计数排序 |                |            |            |            |          |        |
| 基数排序 |                |            |            |            |          |        |
|  桶排序  |                |            |            |            |          |        |

### 1. 算法介绍

示例都是以升序排序为例。

#### 1.1 冒泡排序（Bubble Sort）

从头开始两两相互比较，如果顺序错误就调换位置，整个过程是越小的元素会因为交换过程而慢慢浮到数列的顶端。

>待排序数组
>
>5 3 1 9 8 2 4 7
>
>第一轮排序
>
>3 1 5 8 2 4 7 **9**
>
>第二轮排序
>
>1 3 5 2 4 7 **8 9**
>
>第三轮排序
>
>1 3 2 4 5 **7 8 9**
>
>（依此类推）

**特点**：每一轮排序都会遍历所有的数组，每一次遍历的结果可以把最大的放在最后。

两个优化的点（具体看代码注释）

```python
def bubbleSort(arr):
    n = len(arr)
    
    for i in range(0, n):
        swapped = False
        # 每一轮开始时，后i个元素已经有序
        for j in range(0, n-i-1):
            if arr[j] > arr[j+1]:
                arr[j], arr[j+1] = arr[j+1], arr[j]
                swapped = True
        # 如果第一遍遍历发现没有元素交换，可以直接退出循环（说明该数组本身有序）
        if swapped == False:
            break
```

---

#### 1.2 选择排序

重复从未排序的部分找到最小的元素然后将其放在数组开头（找到最小的元素，然后调换第一个位置和该位置的元素）。有两个数组，一个子数组有序（已经排好的），一个无序。

> 待排序数组：
>
> 5 3 1 9 8 2 4 7
>
> 第一轮排序：
>
> **1** 3 5 9 8 2 4 7（调换1和5）
>
> 第二轮排序：
>
> 1 **2** 5 9 8 3 4 7（调换3和2）
>
> （依次类推）

```python
def selectionSort(arr):
    n = len(arr)
    for i in range(n):
        # 从剩余的待排序数组里寻找最小的元素
        min_dix = i
        for j in range(i+1, n):
            if arr[min_dix] > arr[j]:
                min_dix = j
        # 交换位置
        arr[i], arr[min_dix] = arr[min_dix], arr[i]
```

**特点**：默认的选择排序不稳定（可以改写为稳定版本），但无论最坏还是最好都是n方复杂度。

> 输入：4 5 3 2 4* 1
>
> 第一轮：1 5 3 2 4* 4
>
> 位置改变，不稳定。

**复杂度：** 因为无论如何都会扫描两遍，所以最坏最好的情况时间复杂度也一样。

---

#### 1.3 插入排序

构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相对应位置并插入。一般都是在in-place上实现。

> 待排序数组：
>
> 5 3 1 9 8 2 4 7
>
> 第一轮排序：（默认第一个元素5是已排序状态）
>
> **3** **5** 1 9 8 2 4 7
>
> 第二轮排序：（1与5比较交换位置，与3比较交换位置）
>
> **1 3 5** 9 8 2 4 7
>
> 依次类推

```python
def insertSort(arr):
    # 第一个元素默认有序，所以从第二个元素开始遍历
    for i in range(1, len(arr)):
        key = arr[i]
        j = i-1
        # 如果比前一个元素小则交换位置
        while j >= 0 and key < arr[j]:
            arr[j+1] = arr[j]
            j -= 1
        arr[j+1] = key
```

> 用key记住当前这一轮的元素即arr[i]
>
> 再遍历key之前的元素（从i-1到0），如果key比之前的元素小，就把前一个元素的值后移，这里其实只需要移动那个大的值就可以，因为当前key最终会在停下遍历的地方。
>
> 代码中数组的变化过程：
>
> 待排序数组：
>
> 3 5 1 9 8 2 4 7
>
> 加入是第二轮，此时i=2（key=1）
>
> 3 5 5...（赋值移动）
>
> 3 3 5...（此时跳出while循环key=1，j=0）
>
> 1 3 5...（把key赋值给j+1位置）

#### 1.4 希尔排序

希尔排序其实是插入排序的变体，插入排序中，元素只会移动一个位置，当一个元素必须向前移动很远的时候，会涉及到很多元素的移动过程，而**希尔排序是为元素分组，对每组使用直接插入排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件被分成一组，结束算法**。

> 待排序数组：（增量gap=length/2，缩小增量gap=gap/2）
>
> 8 9 1 7 2 3 5 4 6 0
>
> 第一轮排序：（10/2=5=gap，分为5组，8和3比较，9和5比较，1和4比较，7和6比较，2和0比较）
>
> 3 5 1 6 0 8 9 4 7 2
>
> 第二轮排序：（gap=5/2=2=gap，分为2组，[3 1 0 9 7]和[5 6 8 4 2]，分别对两组进行插入排序得到[0 1 3 7 9]和[2 4 5 6 8]
>
> 0 2 1 4 3 5 7 6 9 8
>
> 第三轮排序：（gap=2/2=1，分为1组，就是该列表。)
>
> 0 1 2 3 4 5 6 7 8 9

```python
def shellSort(arr):
    # 初始化gap值
    gap = len(arr) // 2
    while gap > 0:
        i = 0
        j = gap
        # 分组比较并交换值
        while j < len(arr):
            if arr[i] > arr[j]:
                arr[i], arr[j] = arr[j], arr[i]
            i += 1
            j += 1 
        # i不在gap的左侧
        while i-gap != -1:
            if arr[i-gap] > arr[i]:
                arr[i-gap], arr[i] = arr[i], arr[i-gap]
            i -= 1
        gap //= 2
```

