## 十大排序方法总结

### 0. 总览

#### 0.0 分类

- Comparison Sorting（比较排序）
  - Bubble Sort（冒泡排序）
  - Selection Sort（选择排序）
  - Insertion Sort（插入排序）
  - Shell Sort（希尔排序）
  - Merge Sort（归并排序）
  - Quick Sort（快速排序）
- Bucket Sort（桶排序）
- Counting Sort（计数排序）
- Radix Sort（基数排序）
- Heap Sort（堆排序）

#### 0.1 排序涉及的问题：

1. 稳定：若a=b，排序后，ab位置不变；
2. 不稳定：若a=b，排序后，ab位置可能改变；
3. 内排序：所有排序操作都在内存中完成；
4. 外排序：由于数据太大，把数据放在磁盘里，排序通过磁盘和内存的数据传输才能进行；
5. 时间复杂度：分为平均、最坏、最好三种情况；
6. 空间复杂度。

#### 0.2 总结（cheat sheet）

|          | 平均时间复杂度 | 最好的情况 | 最坏的情况 | 空间复杂度 | 排序方式 | 稳定性 |
| :------: | :------------: | :--------: | :--------: | :--------: | :------: | :----: |
| 冒泡排序 |     O(n^2)     |    O(n)    |   O(n^2)   |    O(1)    | In Place |  稳定  |
| 选择排序 |                |            |            |            |          |        |
| 插入排序 |                |            |            |            |          |        |
| 希尔排序 |                |            |            |            |          |        |
| 归并排序 |                |            |            |            |          |        |
| 快速排序 |                |            |            |            |          |        |
|  堆排序  |                |            |            |            |          |        |
| 计数排序 |                |            |            |            |          |        |
| 基数排序 |                |            |            |            |          |        |
|  桶排序  |                |            |            |            |          |        |

### 1. 算法介绍

示例都是以升序排序为例。

#### 1.1 冒泡排序（Bubble Sort）

从头开始两两相互比较，如果顺序错误就调换位置，整个过程是越小的元素会因为交换过程而慢慢浮到数列的顶端。

>待排序数组
>
>5 3 1 9 8 2 4 7
>
>第一轮排序
>
>3 1 5 8 2 4 7 **9**
>
>第二轮排序
>
>1 3 5 2 4 7 **8 9**
>
>第三轮排序
>
>1 3 2 4 5 **7 8 9**
>
>（依此类推）

**特点**：每一轮排序都会遍历所有的数组，每一次遍历的结果可以把最大的放在最后。

两个优化的点（具体看代码注释）

```python
def bubbleSort(arr):
    n = len(arr)
    
    for i in range(0, n):
        swapped = False
        # 每一轮开始时，后i个元素已经有序
        for j in range(0, n-i-1):
            if arr[j] > arr[j+1]:
                arr[j], arr[j+1] = arr[j+1], arr[j]
                swapped = True
        # 如果第一遍遍历发现没有元素交换，可以直接退出循环（说明该数组本身有序）
        if swapped == False:
            break
```

#### 1.2 选择排序

重复从未排序的部分找到最小的元素然后将其放在数组开头（找到最小的元素，然后调换第一个位置和该位置的元素）。有两个数组，一个子数组有序（已经排好的），一个无序。

> 待排序数组：
>
> 5 3 1 9 8 2 4 7
>
> 第一轮排序：
>
> **1** 3 5 9 8 2 4 7（调换1和5）
>
> 第二轮排序：
>
> 1 **2** 5 9 8 3 4 7（调换3和2）
>
> （依次类推）

```python
def selectionSort(arr):
    n = len(arr)
    for i in range(n):
        # 从剩余的待排序数组里寻找最小的元素
        min_dix = i
        for j in range(i+1, n):
            if arr[min_dix] > arr[j]:
                min_dix = j
        # 交换位置
        arr[i], arr[min_dix] = arr[min_dix], arr[i]
```

**特点**：默认的选择排序不稳定（可以改写为稳定版本），但无论最坏还是最好都是n方复杂度。

> 输入：4 5 3 2 4* 1
>
> 第一轮：1 5 3 2 4* 4
>
> 位置改变，不稳定。

