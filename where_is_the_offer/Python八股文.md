## Python八股文

[toc]

### 关于编程

- 仔细想想，高级程序员会倾向于更多用主流约定俗成的方法论/编排方式/工具编码，而这些已经成为共识，所以好读懂

- 我理解的踏实就是对工作认真负责，会想办法用更好的方法实现优化，会尽自己所能考虑到可读性、可维护性和性能，而不是敷衍了事，以最烂的方式糊弄测试验收交差了事（这种人还不少）。对自己有一定的职业追求，会自我提升，抽空进行系统学习，而不是混吃等死，遇到问题才搜索粘贴，搜不到就换轮子。



### 内存泄漏



---

### 多线程

#### 创建多线程

1. 通过threading.Thread进行创建多线程

   > 

2. 定义类，继承threading.Thread，重写里面的 $$ __init__()$$​ 方法和 run方法（创建线程时会自动调用初始化和run方法）

   > 线程执行顺序是乱序的（没有同步）

#### 多线程同步

四种机制：锁机制，信号量，条件判断和同步队列。

##### 锁机制

threading的Lock类，用该类的acquire函数进行加锁，用realease函数进行解锁

##### 同步队列

Python的queue模块中提供了同步的、线程安全的队列类，包括FIFO（先入先出)队列Queue，LIFO（后入先出）队列LifoQueue，和优先级队列PriorityQueue。这些队列都实现了锁原语，能够在多线程中直接使用。可以使用队列来实现线程间的同步。

#### 线程池

##### 传统的多线程

如果本身执行时间不长，大部分时间在创建线程，销毁线程，浪费时间

##### 线程池基本原理：

我们把任务放进队列中去，然后开N个线程，每个线程都去队列中取一个任务，执行完了之后告诉系统说我执行完了，然后接着去队列中取下一个任务，直至队列中所有任务取空，退出线程。

##### 线程池数目设置

本质上是说，CPU执行A，B去IO，然后A去IO，B来CPU，完美避开

但是Python GIL 机制本质上其实只有一个线程，并没有线程并发的情况

---

### GIL全局解释器锁

全局解释器锁，只是CPython编译器的机制

> In CPython, the global interpreter lock, or GIL, is a mutex that prevents multiple native threads from executing Python bytecodes at once. This lock is necessary mainly because CPython’s memory management is not thread-safe. (However, since the GIL exists, other features have grown to depend on the guarantees that it enforces.)

##### 优点：

简单来说，它在单线程的情况更快，并且在和 C 库结合时更方便，而且不用考虑线程安全问题，这也是早期 Python 最常见的应用场景和优势。

##### why

因为Cpython内存管理不是线程安全的，需要GIL来保证多个原生线程不会并发执行Python字节码。

由于多个线程同时对数据进行操作，会引发数据不一致，导致`内存泄漏`，我们可以对其进行加锁，所以Cpython就创建了GIL锁，但锁太多会导致死锁和性能降低（频繁获取释放锁）

- 设置mutex来保证单个资源不被多个线程修改（解决互斥，但会有死锁）
- 一个变量一把锁，多个变量很多锁，可能会导致死锁（你的在我这，我的在你那），设置全局锁（预防死锁）

GIL 的全局锁即所有资源一个锁，任何Python字节码的执行都需要获取解释器锁，而且不需要太多的性能上的开销，但也导致了使所有受CPU约束的Python程序（CPU密集型）都是单线程的。

##### 争议

因为GIL的存在，Python其实不存在真正的多线层并发，CPU多核的资源也没能很好的利用，Python3.2版本为线程添加了可以自己修改优先级的功能，但Python为什么依然不舍弃掉GIL呢？

- 单线程情况下更快。
- 瓶颈在于 I/O 的多线程环境下更快。
- CPU 耗时操作发生在 C 库调用上时更快。
- 编写 C 扩展会更容易：除法你手动指定，否则不会发生 Python 线程切换的问题。
- 封装 C 库变得更容易，因为不需要考虑线程安全问题。如果该库不是线程安全的，你只需要保证调用时 GIL 是锁定的。

##### 无法解决的问题

几遍GIL存在，也无法解决多线程同步问题，比如当我们利用多线程同时对某个变量a进行修改（如+1操作），a的值可能并不是我们预想的结果，这是因为Python的每行代码不是原子化的操作。

```c
19 LOAD_GLOBAL              1 (n) # 加载全局变量
22 LOAD_CONST               3 (1) # 加载常数 1
25 BINARY_ADD                     # 进行二进制加法
26 STORE_GLOBAL             1 (n) # 运算结果保存至变量 a
```

Python的 `a = a+1` 这一代码编译后是分成了四步，线程在执行这四步的过程中，可能会让出GIL，这样 改行代码的运算过程其实就被打乱了。所以结果会出现问题。

##### 总结

1. 对于`IO密集型` 应用，多线程的应用和多进程应用区别不大，因为GIL会被 IO 打断释放资源，线程都可以获取资源，而且多线程通讯成本低于多进程，因此偏向使用 **多线程**。
2. 对于 `计算密集型` 应用，因为 CPU一直处于被占用状态，GIL锁在规定时间才会被释放，导致大多数线程处于等待（劣势状态），此时采用**多进程+协程**

---

### 协程

在**计算密集型**应用中，GIL机制导致多线程失效，所以协程这一概念应运而生。

##### 发展历程

```python
1. 最初的生成器变形yield/send
2. 引入@asyncio.coroutine和yield from
3. 在最近的Python3.5版本中引入async/await关键字
```

asyncio是Python 3.4版本引入的标准库，直接内置了对异步IO的支持。

 `asyncio`的编程模型就是一个消息循环。我们从`asyncio`模块中直接获取一个`EventLoop`的引用，然后把需要执行的协程扔到`EventLoop`中执行，就实现了异步IO。

 Python的在3.4中引入了协程的概念，可是这个还是以生成器对象为基础。

 Python 3.5添加了async和await这两个关键字，分别用来替换`asyncio.coroutine`和`yield from`。

 python3.5则确定了协程的语法。下面将简单介绍asyncio的使用。实现协程的不仅仅是asyncio，tornado和gevent， vloop都实现了类似的功能。

